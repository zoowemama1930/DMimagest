### 定义一个pod

一个pod存在多个容器，公用一个ip地址。

#### 如何生成一个pod的yaml

##### 1）--dry-run方式

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161302578.png)

把yaml输入文件中

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161303797.png)

##### 2）官网拷贝

这里不多做介绍

#### 如何编写一个pod的yaml文件

##### 1）查看资源对象-版本--pod版本

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161307617.png)

##### 2）yaml文件定义pod的版本

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161306224.png)

##### 3）查看如何定义资源类型

**查看pod资源对象的定义方法**

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161335425.png)

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161311763.png)

**查看pod.spec定义方法**

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161325754.png)



##### 4）定义kind、metadatas等资源类型

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161316664.png)

#### 修改容器的启动命令（使用cmd、ags）

##### 1)使用cmd覆盖entrypoint

创建pod容器沉睡10秒

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161459406.png)

cmd将默认的启动命令覆盖使得容器沉睡10秒

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161329515.png)

##### 2）使用ags覆盖cmd

这里不展开演示

#### pod的状态及问题排查方法

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161336017.png)

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161336523.png)

pod处于running状态，redy数值相等且restarts的数据不再增加，可判定pod为可用

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161341151.png)

当配置为nerver restart时，pod可用时status显示为succecced

node节点挂掉status显示为unkown

#### pod的镜像拉取策略（pod中容器的镜像拉取）

##### 1)always

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161352262.png)

##### 2)nerver

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161352215.png)

#####  3)IfNotpresent

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161353077.png)

 

####  pod重启策略（pod中容器的重启策略）

##### 1）always

always中容器失效的情况指的是可能网络原因、配置有误等等原因导致的容器失效。

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161411555.png)

##### 2）onfailure

适用于job定时计划任务

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161412642.png)

##### 3）never

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161412266.png)

#### 探针的四种探测方法

startupprobe优先进行探测，探测失败了再进行livenessprobe和readinessProbe的探测。正常情况下，容器比较重要时，那么一个pod中有多个容器那么每个容器都需要配置一个健康检查。

##### 1）startupprobe（仅探测一次）

适合于启动比较慢的容器。仅探测一次的意思是它检测出成功即成功，则不会循环探测了。

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161421402.png)

##### 2）livenessprobe存活探针（循环探测）

功能与startupprobe类似，唯一的区别是存活探针属于循环探测，无论容器启动成功与否，持续循环探测。适合于启动比较快的容器。属于生产中常见且重要的配置。探测失败重启容器。

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161421219.png)

##### 3) readinessProbe就绪探针（循环探测）

无论容器启动成功与否，持续循环探测。适合于启动比较快的容器。属于生产中常见且重要的配置。探测失败切断转发到此容器的流量。

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest1/main/202409161421457.png)

#### 零宕机服务发布liveness和readines

##### ReadinessProbe

检测失败则切断流量。常用于通过发起http请求根据返回值的情况探测容器的健康情况。

###### ![](https://raw.githubusercontent.com/zoowemama1930/DMimagest/main/20240916205757.png)

##### livenessProbe

检测失败则重启容器。常用于通过探测端口的存活情况判断容器的健康。

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest/main/20240916210305.png)

###### 参数说明：

```shell
initialdelayseconds: ReadinessProbe探针延迟执行的时间。适用于启动时间较慢的容器
timeoutSeconds: 请求80端口的超时时间，超时则反馈结果
periodseconds: 循环探测的时间间隔
seccessThreshold: 1 #探测1次成功，则接入流量。根据实际需求配置
failureThreshold: 2 #探测2次失败，则切断流量。根据实际需求配置
```

#### startupProbe

适用于启动慢的容器。假设k8s的版本大于1.16，且容器需要180秒启动，那么我们可以将检测间隔时间调为20秒检测一次，超过10次失败则断定容器启动失败。正好200秒，但容器启动的时间不一定掐准180秒时，因其他因素导致启动需要202秒，那么这个配置是不现实的，我们可以拉长为400秒（20秒间隔检测+20次检测失败次数）。由于startupProbe无论检测成功与否，之后都不会持续循环健康检测，也就是检测的次数就一次，检测间隔+检测次数的时长只要不是特别的离谱都不会增加宿主机的负担。

此外，我们还可以结合ReadinessProbe或livenessProbe搭配使用，实现无论成功与否持续循环健康检测，检测失败后的容器重启和容器流量的接收（或拒绝）由它们决定的。ReadinessProbe或livenessProbe间隔时间与检测失败的次数不能过长，因为是持续检测的过程，这样会增加宿主机的负担。

实验：

1.拉起pod,登录容器，删除请求路径下的目录。观察健康检查的次数、容器重启的次数或失败的容器不再获取请求的流量等等。

#### 零宕机服务发布---pod启动的过程

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest/main/20240916222819.png)

#### pod的平滑退出

![](https://raw.githubusercontent.com/zoowemama1930/DMimagest/main/20240916223141.png)

#### 零宕机服务发布---prestop&prestart

使用prestop和prestart可能存在和容器同一时间执行命令的问题，可能会引发prestop和prestart操作未执行完时，容器无法启动。为了解决这个问题，初始化容器initcontainerd更适合替代prestop和prestart的工作。